"use strict";(self.webpackChunkcef_website=self.webpackChunkcef_website||[]).push([[18],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||a;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(7294),o=n(6010);const a="tabItem_Ymn6";function s(e){let{children:t,hidden:n,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,o.Z)(a,s),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>q});var r=n(7462),o=n(7294),a=n(6010),s=n(2466),i=n(6550),l=n(1980),u=n(7392),c=n(12);function d(e){return function(e){return o.Children.map(e,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:o}}=e;return{value:t,label:n,attributes:r,default:o}}))}function p(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.k6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(a),(0,o.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(r.location.search);t.set(a,e),r.replace({...r.location,search:t.toString()})}),[a,r])]}function b(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,a=p(e),[s,i]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[l,u]=m({queryString:n,groupId:r}),[d,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,a]=(0,c.Nk)(n);return[r,(0,o.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:r}),f=(()=>{const e=l??d;return h({value:e,tabValues:a})?e:null})();(0,o.useLayoutEffect)((()=>{f&&i(f)}),[f]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!h({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),b(e)}),[u,b,a]),tabValues:a}}var f=n(2389);const k="tabList__CuJ",g="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:i,selectValue:l,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),r=u[n].value;r!==i&&(d(t),l(r))},h=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:s}=e;return o.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>c.push(e),onKeyDown:h,onClick:p},s,{className:(0,a.Z)("tabs__item",g,s?.className,{"tabs__item--active":i===t})}),n??t)})))}function w(e){let{lazy:t,children:n,selectedValue:r}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===r));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function v(e){const t=b(e);return o.createElement("div",{className:(0,a.Z)("tabs-container",k)},o.createElement(y,(0,r.Z)({},e,t)),o.createElement(w,(0,r.Z)({},e,t)))}function q(e){const t=(0,f.Z)();return o.createElement(v,(0,r.Z)({key:String(t)},e))}},1872:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>u,toc:()=>d});var r=n(7462),o=(n(7294),n(3905)),a=n(5162),s=n(4866);const i={sidebar_position:2},l="Motivation",u={unversionedId:"motivation",id:"motivation",title:"Motivation",description:"NextJS provides no \u201cofficial\u201d way to handle requests on a method basis, and the response can only be typed as a combination of all the possible return values, meaning it\u2019s much easier to accidentally write unreliable code and return an unintended result for a request (as there is no way to prevent accidentally returning the response for a GET in a POST request, for example).",source:"@site/docs/motivation.mdx",sourceDirName:".",slug:"/motivation",permalink:"/create-endpoint-factory/motivation",draft:!1,editUrl:"https://github.com/actual-experience/create-endpoint-factory/tree/main/website/docs/motivation.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Getting Started",permalink:"/create-endpoint-factory/"},next:{title:"Concepts",permalink:"/create-endpoint-factory/category/concepts"}},c={},d=[{value:"In-depth comparison",id:"in-depth-comparison",level:3}],p={toc:d};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"motivation"},"Motivation"),(0,o.kt)("p",null,"NextJS provides no \u201cofficial\u201d way to handle requests on a method basis, and the response can only be typed as a combination of all the possible return values, meaning it\u2019s much easier to accidentally write unreliable code and return an unintended result for a request (as there is no way to prevent accidentally returning the response for a ",(0,o.kt)("inlineCode",{parentName:"p"},"GET")," in a ",(0,o.kt)("inlineCode",{parentName:"p"},"POST")," request, for example)."),(0,o.kt)("h3",{id:"in-depth-comparison"},"In-depth comparison"),(0,o.kt)("p",null,"A NextJS handler for a REST endpoint (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"api/book/:id"),") could be implemented as below: (using Zod for schema validation and Sequelize for database interaction)"),(0,o.kt)(s.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,o.kt)(a.Z,{value:"ts",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Base NextJS example" collapsible showLineNumbers',title:'"Base',NextJS:!0,'example"':!0,collapsible:!0,showLineNumbers:!0},"import type { NextApiRequest, NextApiResponse } from 'next';\nimport z from 'zod';\nimport type { Tokens } from '../../../src/server/auth';\nimport { getAuthTokens } from '../../../src/server/auth';\nimport type { Book } from '../../../src/server/books';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<{ book: Book } | { edited: boolean } | { error: string }>\n) {\n  // highlight-start\n  // authenticate\n  // needs to be manually included for each API route or made into a wrapper like `withAuth(handler)`\n  let tokens: Tokens;\n  try {\n    tokens = getAuthTokens(req.headers);\n    if (!tokens) {\n      throw new Error('invalid tokens');\n    }\n  } catch (err) {\n    console.error(err);\n    return res.status(401).json({ error: 'Failed to authenticate' });\n  }\n  // highlight-end\n  // process the request\n  try {\n    const book = await getBookFromReq(req); // reusable util\n    if (!book) {\n      return res.status(404).json({ error: 'No book found' });\n    }\n    if (req.method === 'GET') {\n      if (Math.random() > 0.5) {\n        // error-start\n        // this is the wrong response but typescript doesn't know that\n        return res.status(200).json({ edited: true });\n        // error-end\n      }\n      return res.status(200).json({ book });\n    } else if (req.method === 'PUT') {\n      const parseResult = UpdateRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        console.error(parseResult.error);\n        return res.status(400).json({ error: 'Invalid body provided' });\n      }\n      const { data } = parseResult;\n      await book.update(data);\n      return res.status(200).json({ edited: true });\n    } else if (req.method === 'DELETE') {\n      await book.destroy();\n      return res.status(204).end();\n    } else {\n      // highlight-start\n      // handle unrecognised methods (and OPTIONS requests)\n      // again, needs to be manually included in each route\n      res.setHeader('Allow', 'GET,PUT,DELETE');\n      return res.status(req.method === 'OPTIONS' ? 204 : 405).end();\n      // highlight-end\n    }\n  } catch (err) {\n    // highlight-start\n    // catch any uncaught errors and ensure error response is consistent\n    console.error(err);\n    res.status(500).json({ error: 'something went wrong' });\n    // highlight-end\n  }\n}\n"))),(0,o.kt)(a.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Base NextJS example" collapsible showLineNumbers',title:'"Base',NextJS:!0,'example"':!0,collapsible:!0,showLineNumbers:!0},"import z from 'zod';\nimport { getAuthTokens } from '../../../src/server/auth';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nexport default async function handler(req, res) {\n  // highlight-start\n  // authenticate\n  // needs to be manually included for each API route or made into a wrapper like `withAuth(handler)`\n  let tokens;\n  try {\n    tokens = getAuthTokens(req.headers);\n    if (!tokens) {\n      throw new Error('invalid tokens');\n    }\n  } catch (err) {\n    console.error(err);\n    return res.status(401).json({ error: 'Failed to authenticate' });\n  }\n  // highlight-end\n  // process the request\n  try {\n    const book = await getBookFromReq(req); // reusable util\n    if (!book) {\n      return res.status(404).json({ error: 'No book found' });\n    }\n    if (req.method === 'GET') {\n      if (Math.random() > 0.5) {\n        // error-start\n        // this is the wrong response but typescript doesn't know that\n        return res.status(200).json({ edited: true });\n        // error-end\n      }\n      return res.status(200).json({ book });\n    } else if (req.method === 'PUT') {\n      const parseResult = UpdateRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        console.error(parseResult.error);\n        return res.status(400).json({ error: 'Invalid body provided' });\n      }\n      const { data } = parseResult;\n      await book.update(data);\n      return res.status(200).json({ edited: true });\n    } else if (req.method === 'DELETE') {\n      await book.destroy();\n      return res.status(204).end();\n    } else {\n      // highlight-start\n      // handle unrecognised methods (and OPTIONS requests)\n      // again, needs to be manually included in each route\n      res.setHeader('Allow', 'GET,PUT,DELETE');\n      return res.status(req.method === 'OPTIONS' ? 204 : 405).end();\n      // highlight-end\n    }\n  } catch (err) {\n    // highlight-start\n    // catch any uncaught errors and ensure error response is consistent\n    console.error(err);\n    res.status(500).json({ error: 'something went wrong' });\n    // highlight-end\n  }\n}\n")))),(0,o.kt)("p",null,"As highlighted above, this has multiple pitfalls."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Type safety isn't as good as it could be, as there's no way for Typescript to know which responses are allowed per method"),(0,o.kt)("li",{parentName:"ul"},"Authentication needs to be included for each API route."),(0,o.kt)("li",{parentName:"ul"},"The handler needs to know how to handle an unrecognised method, which is easily forgotten."),(0,o.kt)("li",{parentName:"ul"},"If it's desired for all uncaught requests to be reformatted to match the normal error format, this needs to be done manually.")),(0,o.kt)("p",null,"The Typescript concerns can be somewhat alleviated by moving each method to its own mini handler, which then get called accordingly by a switch case:"),(0,o.kt)(s.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,o.kt)(a.Z,{value:"ts",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Second attempt, with switch case and individual handlers" collapsible showLineNumbers',title:'"Second',"attempt,":!0,with:!0,switch:!0,case:!0,and:!0,individual:!0,'handlers"':!0,collapsible:!0,showLineNumbers:!0},"import type { NextApiRequest, NextApiResponse } from 'next';\nimport z from 'zod';\nimport type { Tokens } from '../../../src/server/auth';\nimport { getAuthTokens } from '../../../src/server/auth';\nimport type { Book } from '../../../src/server/books';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst getHandler = (\n  req: NextApiRequest,\n  res: NextApiResponse<{ book: Book }>,\n  tokens: Tokens,\n  book: Book\n) => {\n  if (Math.random() > 0.5) {\n    // success-start\n    // this will now error, yay!\n    // @ts-expect-error\n    return res.status(200).json({ edited: true });\n    // success-end\n  }\n  return res.status(200).json({ book });\n};\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nconst putHandler = async (\n  req: NextApiRequest,\n  res: NextApiResponse<{ edited: boolean } | { error: string }>,\n  tokens: Tokens,\n  book: Book\n) => {\n  const parseResult = UpdateRequestSchema.safeParse(req.body);\n  if (!parseResult.success) {\n    console.error(parseResult.error);\n    return res.status(400).json({ error: 'Invalid body provided' });\n  }\n  const { data } = parseResult;\n  await book.update(data);\n  return res.status(200).json({ edited: true });\n};\n\nconst deleteHandler = async (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  tokens: Tokens,\n  book: Book\n) => {\n  await book.destroy();\n  return res.status(204).end();\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // highlight-start\n  // authenticate\n  // still needs to be manually included for each API route or made into a wrapper like `withAuth(handler)`\n  let tokens: Tokens;\n  try {\n    tokens = getAuthTokens(req.headers);\n    if (!tokens) {\n      throw new Error('invalid tokens');\n    }\n  } catch (err) {\n    console.error(err);\n    return res.status(401).json({ error: 'Failed to authenticate' });\n  }\n  // highlight-end\n  // process the request\n  try {\n    const book = await getBookFromReq(req); // reusable util\n    if (!book) {\n      return res.status(404).json({ error: 'No book found' });\n    }\n    switch (req.method) {\n      case 'GET':\n        return getHandler(req, res, tokens, book);\n      case 'PUT':\n        return putHandler(req, res, tokens, book);\n      case 'DELETE':\n        return deleteHandler(req, res, tokens, book);\n      default: {\n        // highlight-start\n        // handle unrecognised methods (and OPTIONS requests)\n        // still needs to be manually included in each route\n        res.setHeader('Allow', 'GET,PUT,DELETE');\n        return res.status(req.method === 'OPTIONS' ? 204 : 405).end();\n        // highlight-end\n      }\n    }\n  } catch (err) {\n    // highlight-start\n    // catch any uncaught errors and ensure error response is consistent\n    console.error(err);\n    res.status(500).json({ error: 'something went wrong' });\n    // highlight-end\n  }\n}\n"))),(0,o.kt)(a.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Second attempt, with switch case and individual handlers" collapsible showLineNumbers',title:'"Second',"attempt,":!0,with:!0,switch:!0,case:!0,and:!0,individual:!0,'handlers"':!0,collapsible:!0,showLineNumbers:!0},"import z from 'zod';\nimport { getAuthTokens } from '../../../src/server/auth';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst getHandler = (req, res, tokens, book) => {\n  if (Math.random() > 0.5) {\n    // success-start\n    // this will now error, yay!\n\n    return res.status(200).json({ edited: true });\n    // success-end\n  }\n  return res.status(200).json({ book });\n};\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nconst putHandler = async (req, res, tokens, book) => {\n  const parseResult = UpdateRequestSchema.safeParse(req.body);\n  if (!parseResult.success) {\n    console.error(parseResult.error);\n    return res.status(400).json({ error: 'Invalid body provided' });\n  }\n  const { data } = parseResult;\n  await book.update(data);\n  return res.status(200).json({ edited: true });\n};\n\nconst deleteHandler = async (req, res, tokens, book) => {\n  await book.destroy();\n  return res.status(204).end();\n};\n\nexport default async function handler(req, res) {\n  // highlight-start\n  // authenticate\n  // still needs to be manually included for each API route or made into a wrapper like `withAuth(handler)`\n  let tokens;\n  try {\n    tokens = getAuthTokens(req.headers);\n    if (!tokens) {\n      throw new Error('invalid tokens');\n    }\n  } catch (err) {\n    console.error(err);\n    return res.status(401).json({ error: 'Failed to authenticate' });\n  }\n  // highlight-end\n  // process the request\n  try {\n    const book = await getBookFromReq(req); // reusable util\n    if (!book) {\n      return res.status(404).json({ error: 'No book found' });\n    }\n    switch (req.method) {\n      case 'GET':\n        return getHandler(req, res, tokens, book);\n      case 'PUT':\n        return putHandler(req, res, tokens, book);\n      case 'DELETE':\n        return deleteHandler(req, res, tokens, book);\n      default: {\n        // highlight-start\n        // handle unrecognised methods (and OPTIONS requests)\n        // still needs to be manually included in each route\n        res.setHeader('Allow', 'GET,PUT,DELETE');\n        return res.status(req.method === 'OPTIONS' ? 204 : 405).end();\n        // highlight-end\n      }\n    }\n  } catch (err) {\n    // highlight-start\n    // catch any uncaught errors and ensure error response is consistent\n    console.error(err);\n    res.status(500).json({ error: 'something went wrong' });\n    // highlight-end\n  }\n}\n")))),(0,o.kt)("p",null,"This resolves concerns around types, however there's still a lot of code to remember to include in each route. In fact, this approach requires ",(0,o.kt)("em",{parentName:"p"},"more")," code than the basic example above!"),(0,o.kt)("p",null,"We still need to include authentication, handle unsupported methods, and ensure uncaught errors match our desired error format."),(0,o.kt)("p",null,"CEF allows us to address all of these, and more."),(0,o.kt)(s.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,o.kt)(a.Z,{value:"ts",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="With Create Endpoint Factory" collapsible showLineNumbers',title:'"With',Create:!0,Endpoint:!0,'Factory"':!0,collapsible:!0,showLineNumbers:!0},"// file: src/server/index.ts\nimport { createEndpointFactory } from 'next-create-endpoint-factory';\nimport { getAuthTokens } from './auth';\n\nexport const createEndpoint = createEndpointFactory({\n  // success-start\n  // one time setup of authentication\n  // will apply to all endpoints made with `createEndpoint` except those with `disableAuthentication` set\n  authenticate: async (req) => {\n    const tokens = await getAuthTokens(req);\n    if (!tokens) {\n      throw new Error('No tokens found');\n    }\n    return tokens;\n  },\n  // success-end\n});\n\n\n// file: pages/api/book/[id].ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport z from 'zod';\nimport { createEndpoint } from '../../../src/server';\nimport type { Tokens } from '../../../src/server/auth';\nimport { getAuthTokens } from '../../../src/server/auth';\nimport type { Book } from '../../../src/server/books';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nconst endpoint = createEndpoint({\n  methods: (method) => ({\n    get: method<{ book: Book }>({\n      // @ts-expect-error\n      handler: async (req) => {\n        const book = await getBookFromReq(req);\n        if (Math.random() > 0.5) {\n          // success-start\n          // this still causes an error\n          return { edited: true };\n          // success-end\n        }\n        return { book };\n      },\n    }),\n    put: method({\n      handler: async (req, res, { failWithCode }) => {\n        const book = await getBookFromReq(req);\n        const parseResult = UpdateRequestSchema.safeParse(req.body);\n        if (!parseResult.success) {\n          throw failWithCode(400, 'invalid body');\n        }\n        await book.update(parseResult.data);\n        return { edited: true };\n      },\n    }),\n    delete: method<void>({\n      handler: async (req) => {\n        const book = await getBookFromReq(req);\n        await book.destroy();\n        // status code is automatically 204 since we didn't return\n      },\n    }),\n  }),\n});\n\nexport default endpoint.handler;\n"))),(0,o.kt)(a.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="With Create Endpoint Factory" collapsible showLineNumbers',title:'"With',Create:!0,Endpoint:!0,'Factory"':!0,collapsible:!0,showLineNumbers:!0},"// file: src/server/index.ts\nimport { createEndpointFactory } from 'next-create-endpoint-factory';\nimport { getAuthTokens } from './auth';\n\nexport const createEndpoint = createEndpointFactory({\n  // success-start\n  // one time setup of authentication\n  // will apply to all endpoints made with `createEndpoint` except those with `disableAuthentication` set\n  authenticate: async (req) => {\n    const tokens = await getAuthTokens(req);\n    if (!tokens) {\n      throw new Error('No tokens found');\n    }\n    return tokens;\n  },\n  // success-end\n});\n\n\n// file: pages/api/book/[id].ts\nimport z from 'zod';\nimport { createEndpoint } from '../../../src/server';\nimport { getBookFromReq } from '../../../src/server/books';\n\nconst UpdateRequestSchema = z.object({\n  name: z.string().optional(),\n  author: z.string().optional(),\n});\n\nconst endpoint = createEndpoint({\n  methods: (method) => ({\n    get: method({\n      handler: async (req) => {\n        const book = await getBookFromReq(req);\n        if (Math.random() > 0.5) {\n          // success-start\n          // this still causes an error\n          return { edited: true };\n          // success-end\n        }\n        return { book };\n      },\n    }),\n    put: method({\n      handler: async (req, res, { failWithCode }) => {\n        const book = await getBookFromReq(req);\n        const parseResult = UpdateRequestSchema.safeParse(req.body);\n        if (!parseResult.success) {\n          throw failWithCode(400, 'invalid body');\n        }\n        await book.update(parseResult.data);\n        return { edited: true };\n      },\n    }),\n    delete: method({\n      handler: async (req) => {\n        const book = await getBookFromReq(req);\n        await book.destroy();\n        // status code is automatically 204 since we didn't return\n      },\n    }),\n  }),\n});\n\nexport default endpoint.handler;\n")))))}h.isMDXComponent=!0}}]);